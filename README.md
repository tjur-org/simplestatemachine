# SimpleStateMachine

This is an implementation of a finite state machine in Kotlin.

The main class `SimpleStateMachine` is open and extendable, but should be usable out of the box for most use cases.

## How to use

Create a class and extend `State`. The only method you are required to override is `process`, which is
where your inputs will enter your state. The method returns a `MessageResult` and there
are already some helper methods you can use, for example, `unhandled()`.

````
class MyFirstState : State() {

    override fun process(message: Message): MessageResult {
        return unhandled()
    }

}
````

The message result generated by `unhandled()` signals to the state machine that your state did not
do anything with the message it received, so if you would have declared that your state has a parent state,
then the state machine would pass the message along to that state instead.

````
override fun getParentState() = BiggerState::class
````

This can be useful if you are for example working with Bluetooth and want to handle losing the
connection, but don't want to implement that in every stage of your communication. Instead, you
can have a parent state that deals with these problems and then hands back control again.

## Handling a message

You should extend the `Message` class with your own to fit your usecase.

It is also good practice to check for your data and always end the method with `unhandled()`:

````
override fun process(message: Message): MessageResult {
    if (message is MyMessage) {
        println(message.helloWorldString)
        return handled()
    }
    return unhandled()
}
````

## Transitioning to a different state

As a result of handling a message, you can return that you want to transition to a different state:

````
if (message is LaunchMessage) {
    return transitionTo(LaunchState::class)
}
````

By default this will clear the message queue in the state machine.

## Initializing states

Typically, you only mention states by their class, such as `MyState::class`. The state machine
initializes them lazily as they are accessed and them keeps them, but that assumes that there
are no parameters for the constructor. If you know that your state cannot be this simple or you'd
prefer to initialize them yourself, then you  can instantiate it beforehand and put your instance in
the state machine:

````
val myState = AdvancedState(missileLaunchCodes)
stateMachine.prepareState(myState)
````

If your state has been prepared this way before the state machine attempts to access it, then it
will use your instance.

## Implementation example

````
class StartingState : State() {
    override fun enter(message: Message?): MessageResult {
        println("Entered StartingState, but transitioning to SecondState")
        return transitionTo(SecondState::class)
    }

    override fun leave() {
        println("Exiting StartingState")
    }

    override fun process(message: Message): MessageResult {
        return unhandled()
    }

}

class SecondState: State() {
    override fun enter(message: Message?): MessageResult {
        println("Entered SecondState")
        return handled()
    }

    override fun process(message: Message): MessageResult {
        println("Got message")
        return handled()
    }

}

fun main(args:Array<String>){
    val stateMachine = SimpleStateMachine(StartingState::class)
    stateMachine.run()
}
````